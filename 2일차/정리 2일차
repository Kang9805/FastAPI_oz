1. Pytest

> 단위 테스트란? 우리가 만든 코드가 '예상한 대로' 작동하는지 검증하는 작업이다.
개발 과정에서 예기치 못한 오류를 빠르게 발견하고 수정할 수 있게 도와준다.

설치: poetry add --group=dev pytest==8.3.4

예시)
def test_simple() -> None:
    print("test")
 # 이 코드는 실제로 무언가를 검증하진 않지만 실행 과정에서 오류가 없기에 성공으로 간주
 # 실행하기 위해선 터미널에서 pytest . 명령어를 실행하면 현재 디렉터리 내 모든 테스트 파일을 찾아 실행


 > Given - When - Then 단위 테스트의 3단계
    1. Given: 테스트에 필요한 재료(입력값, 초기 상태 등)을 준비하는 단계
    2. When: 테스트 대상 함수를 실행하는 단계
    3. Then: 실행 결과를 검증하는 단계/ assert를 사용해 결과가 예상과 일치하는지 확인

예시)
def add(a: int, b: int) -> int:
    return a + b

def test_add() -> None:
    # Given
    a, b = 1, 1

    # When
    result = add(a, b)

    # Then
    assert result == 2 # result가 2와 같은지 검증
    # 이 예시에서 add가 제대로 작동하는지 검증하고 있습니다. 만약 1+1 != 2라면 AssertionError가 발생합니다.

------------------------------------

2. Coverage

> Coverage란?: 테스트가 실행시킨 제품 코드의 비율을 측정하는 도구입니다.
> 왜 필요한가?: 테스트가 닿지 않는 사각지대를 찾아내어 잠재적 버그를 예방하고 테스트의 품질을 높입니다.
> 핵심: 커버리지를 측정할 때 테스트 코드는 반드시 제외하고 제품 코드만 포함시켜야 정확한 결과를 얻을 수 있습니다.
설치: poetry add --group=dev coverage==7.6.9

에시) temp.py (제품 코드)
def add(a: int, b: int) -> int:
    return a + b

def mul(a: int, b: int) -> int:
    return a * b

예시) test_temp.py (테스트 코드)
from temp import add

def test_add() -> None:
    a, b = 1, 1
    result = add(a, b)
    assert result == 2
# test_add() 함수는 add 함수만 호출하고 mul 함수는 전혀 사용하지 않았다.

> 여기서 커버리지 측정하는 방법을 알아보자
# 커버리지 측정과 함께 테스트 실행
poetry run coverage run -m pytest test_temp.py

# 커버리지 보고서 출력 (실행되지 않은 라인 포함)
poetry run coverage report -m

명령어 실행하면 아래와 같은 결과가 출력된다.
Name      Stmts   Miss  Cover   Missing
---------------------------------------
temp.py       4      1    75%   6
---------------------------------------
TOTAL         4      1    75%

1. Stmts (Statements): 주석, 공백 등을 제외한 전체 코드 라인 수(4개)입니다.
2. Miss (Missing): 테스트가 한 번도 실행하지 않은 코드 라인 수(1개)입니다.
3. Cover (Coverage): 커버리지 비율(75%)입니다.
4. Missing: 실행되지 않은 라인의 번호(temp.py의 6번 라인, 즉 return a * b가 누락)를 보여줍니다.
# 이렇게 커버리지 보고서를 통해 mul 함수가 테스트되지 않았다는 사실을 알 수 있었다.

> 테스트 코드는 커버리지 측정에서 제외하기! (Omit)
커버리지는 오직 제품 코드에 대해서만 측정해야한다. 테스트 코드까지 포함하면 커버리지 수치가 실제보다 높게 나와 의미가 없어지기 떄문
pyproject.toml 파일에 다음 설정을 추가하여 테스트 파일을 측정 대상에서 제외할 수 있다.

[tool.coverage.run]
omit = ["*/test_*.py"] # 'test_'로 시작하는 모든 파이썬 파일을 제외

> HTML 보고서로 더 자세히 보기
poetry run coverage html
명령어를 실행하면 더욱 상세한 HTML 보고서를 생성합니다.
이 보고서는 어떤 라인이 실행되었고, 어떤 라인이 실행되지 않았는지 시각적으로 쉽게 확인할 수 있어 매우 유용합니다.

<주요 명령어>
poetry run coverage run -m pytest : 커버리지 측정과 함께 테스트 실행
poetry run coverage report -m : 커버리지 요약 보고서 출력
poetry run coverage html : 상세한 HTML 보고서 생성

------------------------------------

3. Poetry를 활용한 의존성 관리: Dev Dependency 이해하기

> Dev Dependency란 무엇인가?
소프트웨어 개발에서 의존성(Dependency)은 두 가지 종류로 나눌 수 있다.
메인 종속성: 서버가 실행되는 데 필수적인 라이브러리 (예: FastAPI, Uvicorn).
개발 종속성 (dev dependency): 개발 과정에서만 필요하고, 실제 서비스가 구동될 때는 사용되지 않는 라이브러리 (예: Pytest, Black, MyPy, Ruff 등).
Poetry에서는 [tool.poetry.group.dev.dependencies]를 통해 개발 종속성을 명확하게 분리하여 관리합니다.

> 왜 개발 종속성을 분리해야할까?
분리하면 프로덕션 환경에서 불필요한 라이브러리 설치하는 시간과 공간을 남비하지 않을 수 있어서?
 - 특히 Docker 같은 컨테이너 환경에서 큰 이점을 가진다고 GPT가 알려줬다.

> 개발 종속성을 제외한 메인 종속성만 설치하려면?
poetry install --no-root --only main
    # --no-root: 현재 프로젝트를 라이브러리가 아닌 애플리케이션으로 간주하여 자기 자신을 설치하지 않는다.
    # --only main: dev 그룹이 아닌 main 그룹의 종속성만 설치

> 자동화 테스트가 필요한 이유(GPT)
안전하게 코드를 수정하고 개선하기 위해서입니다.
테스트가 없으면 개발자는 코드의 일부를 수정했을 때, 예상치 못한 곳에서 버그가 발생할까 봐 두려워하게 됩니다.
이런 두려움은 결국 코드 변경을 주저하게 만들어 프로젝트의 성장을 방해합니다.

자동화 테스트는 사람이 아닌 코드로 코드를 검증하기 때문에, 반복적인 확인 작업을 실수 없이 빠르게 수행합니다.
이를 통해 개발자는 코드가 의도한 대로 작동함을 확신하고, 자신감을 가지고 코드 품질을 높여 나갈 수 있습니다.
한마디로, 테스트는 개발자가 버그 걱정 없이 코딩에 집중할 수 있도록 돕는 가장 강력한 도구입니다.


------------------------------------

4. 테스트 스크립트 작성 및 CI 도구 활용

> 비동기(Async)테스트를 위한 Pytest 설정
    pytest-asyncio 설치
        poetry add --group=dev pytest-asyncio==0.25.0

    pyproject.toml 설정
        [tool.pytest.ini_options]
        asyncio_mode = "auto"
        asyncio_default_fixture_loop_scope = "session"

예시) test.sh
set -eo pipefail

COLOR_GREEN=`tput setaf 2;`
COLOR_NC=`tput sgr0;` # No Color

echo "Starting black"
poetry run black .
echo "OK"

echo "Starting ruff"
poetry run ruff check --select I --fix
poetry run ruff check --fix
echo "OK"

echo "Starting mypy"
poetry run mypy .
echo "OK"

echo "Starting pytest with coverage"
poetry run coverage run -m pytest
poetry run coverage report -m
poetry run coverage html

echo "${COLOR_GREEN}All tests passed successfully!${COLOR_NC}"
# 이 스크립트는 모든 도구가 성공적으로 실행되어야만 마지막에 "All tests passed successfully!" 메시지를 출력한다.
# 만약 중간에 하나라도 실패하면 스크립트가 멈추기 때문에 문제 있는 부분 바로 파악 가능!
# 이처럼 테스트 스크립트를 작성하면 개발 환경을 일관되게 유지하고, 지속적인 통합(CI)을 자동화하여 효율적으로 코드를 관리할 수 있다.

<주요 스크립트 기능>
set -eo pipefail: 스크립트 실행 중 에러가 발생하면 즉시 중단되도록 설정
black: 코드 스타일을 자동으로 포맷팅
ruff: 코드에서 문법적, 스타일적 오류를 찾아내고 일부는 자동으로 수정
mypy: 코드의 타입(자료형) 오류를 확인
pytest와 coverage: 단위 테스트를 실행하고, 코드 커버리지를 측정해 보고서(터미널 및 HTML)를 생성


------------------------------------

5. Github action (이 파트는 본인이 이해가 잘 되지 않아 GPT가 다 알려준 정보)

매번 Github에 push 할 떄마다 black, ruff, mypy, pytest까지 모든 검사가 자동으로 실행되도록 만들어주는 코드를 작성해보도록 하겠다.

.github/workflows/ci.yml

name: CI

on:
  push:

jobs:
  static-analysis:
    runs-on: ubuntu-22.04
    steps:
      - name: Check out the codes
        uses: actions/checkout@v2

      - name: Setup python environment
        id: setup-python
        uses: actions/setup-python@v2
        with:
          python-version: "3.13"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 - --version 1.8.5

      - name: Register Poetry bin
        run: echo "${HOME}/.poetry/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: poetry install --no-root

      - name: Run Black
        run: poetry run black . --check

      - name: Run Ruff
        run: |
          poetry run ruff check --select I
          poetry run ruff check

      - name: Run Mypy
        run: poetry run mypy .

  test:
    runs-on: ubuntu-22.04
    steps:
      - name: Check out the codes
        uses: actions/checkout@v2

      - name: Setup python environment
        id: setup-python
        uses: actions/setup-python@v2
        with:
          python-version: "3.13"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 - --version 1.8.5

      - name: Register Poetry bin
        run: echo "${HOME}/.poetry/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: poetry install --no-root

      - name: Run tests
        run: |
          poetry run coverage run -m pytest .
          poetry run coverage report -m
<주요 요소>
on: 언제 워크플로우를 실행할지 정의, ex) on: push는 코드를 푸시할 때마다 워크플로우를 실행하라는 의미

jobs: 하나의 워크플로우는 여러 개의 작업(job)으로 구성. 이 작업들은 기본적으로 병렬로 실행되어 CI 속도를 높일 수 있다.
예를 들어, 코드 정적 분석(static-analysis)과 단위 테스트(test)를 별도의 작업으로 분리하면 동시에 실행되므로 전체 작업 시간이 단축된다.

runs-on: 작업을 실행할 환경을 지정. 보통 ubuntu-latest와 같이 운영체제를 지정.

steps: 하나의 작업(job)은 여러 개의 단계(step)로 이루어진다. 각 단계는 특정 명령어를 실행하거나 다른 액션을 호출.

uses: 실행할 액션을 지정. 이미 만들어진 액션을 재사용하여 복잡한 설정을 간편하게 처리할 수 있다.

with: uses로 지정한 액션에 전달할 인자(parameter)를 정의한다.

run: 실행할 셸 명령어를 작성. 여러 줄의 명령어를 작성할 때는 YAML 문법의 | (파이프)를 사용